static const char * usage =
"usage: genhorn [-h|-a|-r|-k <size>|-s <seed>] [<variables> [<clauses>]]\n"
;

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

static bool antihorn = false;
static bool renameable = false;

static int seed = -1;
static int size = -1;
static int variables = -1;
static int clauses = -1;

static void
die (const char * fmt, ...)
{
  va_list ap;
  fputs ("genhorn: error: ", stderr);
  va_start (ap, fmt);
  vfprintf (stderr, fmt, ap);
  va_end (ap);
  fputc ('\n', stderr);
  exit (1);
}

static int
parse (const char * arg)
{
  if (!*arg)
    return -1;
  int res = 0, ch;
  while ((ch = *arg++))
    {
      if (!isdigit (ch))
	return -1;
      if (INT_MAX/10 < res)
	return -1;
      res *= 10;
      const int digit = ch - '0';
      if (INT_MAX - ch < res)
	return -1;
      res += digit;
    }
  return res;
}

static int * map;
static int * clause;

int
main (int argc, char ** argv)
{
  for (int i = 1; i < argc; i++)
    {
      const char * arg = argv[i];
      if (!strcmp (arg, "-h"))
        fputs (usage, stdout), exit (0);
      else if (!strcmp (arg, "-a"))
	antihorn = true;
      else if (!strcmp (arg, "-r"))
	renameable = true;
      else if (!strcmp (arg, "-k"))
	{
	  if (++i == argc)
	    die ("argument to '-k' missing (try '-h')");
	  if (size >= 0)
	    die ("multiple '-k' options");
	  if ((size = parse (arg = argv[i])) < 2)
	    die ("invalid argument in '-k %s' (requires number > 1)", arg);
	}
      else if (!strcmp (arg, "-s"))
	{
	  if (++i == argc)
	    die ("argument to '-s' missing (try '-h')");
	  if (seed >= 0)
	    die ("multiple '-s' options");
	  if ((seed = parse (arg = argv[i])) < 0)
	    die ("invalid argument in '-s %s' (try '-h')", arg);
	}
      else if (clauses >= 0)
        die ("too many arguments (try '-h')");
      else if (variables < 0)
        {
	  if ((variables = parse (arg)) < 0 || variables > INT_MAX/2)
	    die ("invalid number of variables '%s'", arg);
	}
      else if ((clauses = parse (arg)) < 0)
	die ("invalid number of clauses '%s'", arg);
    }
  if (variables < size)
    die ("size %d exceeds variables %d", size, variables);
  if (size < 0)
    size = (variables >=0 && (variables < 3) ? variables : 3);
  if (seed < 0)
    seed = 1;
  if (variables < 0)
    variables = ((size > 10) ? size : 10);
  if (clauses < 0)
    clauses = variables * 4.26;
  printf ("c generated by 'genhorn");
  if (renameable)
    printf (" -r");
  printf (" -k %d -s %d %d %d'\n", size, seed, variables, clauses);
  if (!(map = malloc (sizeof (int) * (2u*variables + 1))))
    die ("failed to allocated variable map");
  map += variables;
  if (!(clause = malloc (sizeof (int) * size)))
    die ("failed to allocated clause buffer");
  srandom (seed);
  if (renameable)
    {
      for (int i = 1; i <= variables; i++)
	{
	  int sign = (random () & (1 << 15)) ? -1 : 1;
	  map[i] = sign * i;
	  map[-i] = -sign * i;
	}
      srandom (seed);
    }
  else
    for (int i = -variables; i<= variables; i++)
      if (i)
	map[i] = i;
  printf ("p cnf %d %d\n", variables, clauses);
  for (int i = 0; i < clauses; i++)
    {
      int pos = random () % (size + 1);
      for (int j = 0; j < size; j++)
	{
	  bool found;
	  int var;
	  do 
	    {
	      found = false;
	      var = random () % variables + 1;
	      for (int k = 0; !found && k < j; k++)
		if (abs (clause[k]) == var)
		  found = true;
	    }
	  while (found);
	  if (antihorn)
	    var = -var;
	  clause[j] = map [(j == pos) ? var : -var];
	}
      for (int j = 0; j < size; j++)
	printf ("%d ", clause[j]);
      printf ("0\n");
    }
  free (clause);
  map -= variables;
  free (map);
  return 0;
}
